# 优化学习：9. SuperMemo在随机学习中的应用

### [彼得·沃兹尼亚克](https://super-memory.com/english/company/wozniak.htm), 1990年

这段文字来自彼得 · 沃兹尼亚克, [优化学习](https://super-memory.com/english/ol.htm), 硕士论文，波兹南科技大学，1990年，并被改编为网络上的独立文章（P.A.Wozniak, M. K. Hejwosz, Jul 20, 2010）。请注意，这段文字是相当过时的，而且是大胆假设的。它被张贴在这里，只是因为SuperMemo的用户无休止的要求，而不仅仅是。它不应该被看作是沃兹尼亚克博士或SuperMemo World对所考虑的主题的现有立场的反映。它被放置在网络上只是为了存档。在阅读之前，请注意，只要符合基本假设，**随机学习的假设概念大致上可以用定义明确的**程序性学习现象来代替：在随机学习中，是大脑需要找出需要强化的突触连接（基本上通过试错）。在整个文本中，随机学习与**确定性学习（deterministic）**相对立，后者大致与**陈述性学习**相对应。

SuperMemo方法已经成功地应用于确定性学习领域，最终证明了其有效性和实效性。然而，随机学习（见第10章记忆的生理学）是由不同的原则所支配的，一个有趣的问题出现了，即SuperMemo记忆法是否也可以应用于这种形式的学习。早在1985年，SuperMemo记忆法就被顺便应用于随机学习的领域，如打字、弹贝斯、弹钢琴和打鼓训练。现在，我们将考虑基于SuperMemo的算法在触摸打字和鼓的训练中更经常的应用的最新结果。

## 9.1.基于SuperMemo的触摸打字训练

毫无疑问，触摸式打字训练可以被归类为一个涉及随机学习的过程。神经系统不知道也不可能从任何渠道了解什么肌肉、以什么顺序、以什么时间进行刺激。指导手指超越意识水平所需的全部控制信息必须由运动系统本身的神经网络来完成。我们已经开发了一个特殊的程序来监督基于SuperMemo的触摸打字训练。该程序的结构和选项树与用于确定性学习的SuperMemo程序相同（见第四章）。然而，有两个选项是为了应用触摸打字训练而实现的。这些选项是**Append**（用于向数据库添加新项目）和**Test**（用于重复的过程）。触摸打字训练中使用的项目是短语（3-20个字符）的形式，在重复过程中进行练习。选项**Append**应提供一种方法，选择那些练习起来似乎对学生的进步贡献最大的短语。

评估学生的进步有两个标准：打字速度和错误的数量。调和这两个标准的最常见的方法是对错误的击键的惩罚就是分配时间。在大多数情况下，那些打字速度最慢的短语（包括错误的惩罚）可以被认为是最有希望的候选者，可以进行强化练习以提高整体成绩。因此，选择应该被添加到SuperMemo数据库的短语应该包括使用有代表性的文本测试学生的打字技能，并检测那些最明显的有助于降低总打字分数的片段。

为了简化这一过程，我们假设一个短语应该由一个以空格为界的单词组成。如果一个词的消耗时间或最低单字打字速度（在该词中打出一个单字的最低速度）大大低于学生的平均打字速度，该词将被选为一个项目的候选。

在考虑的实施中，使用了以下公式：

> ```

> x := word_speed*(1/word_length);

> if x < average_speed*0.6 OR

>     character_speed < average_speed*0.4 then

>     append_word;

>

> ```

>

> where:

>

> - `x` - auxiliary variable

> - `word_speed` - 所考虑的单词的打字速度

> - `word_length` - 所考虑的单词中的字符数

> - `character_speed` - 所考虑的单词中单个字符的最低打字速度。

> - `平均速度` - 学生的平均打字速度

> - `append_word` - 存储过程将该词追加到数据库中。

请注意，在第一条语句中，变量`x`是在`word_speed`的基础上计算的，以便抵消由「较长的单词具有较慢的打字速度」这一规则造成的差异。变量`x`反映了不同长度短语的`word_speed`的标准化。

众所周知，一个词在给定的上下文中可以打得慢一些，通常是作为前一个词的结果。因此，附加算法总是产生一个与给定单词相关的伴随条目。伴随条目是由测试文本中被考虑的单词和其前面的单词组成。

**Test**选项，仅次于**Append**，为了触摸打字程序而被修改，负责重复存储在数据库中的特定短语，以符合SuperMemo的重复间隔。重复中使用的间隔是根据该公式计算的：

> ```

> I(1) = quality+1

> I（i）=I（i-1）*EF

>

> ```

>

> where:

>

> - `I(i)` - 第i次重复后的间隔时间（天）

> - `quality` - 为第一次重复的质量从0-5的评分中进行打分

> - `EF` - 所考虑条目的E-系数

请注意，与以前的情况不同，在确定第一个间隔时，涉及到重复的品质。这是一个实验性的解决方案，其有效性既没有被证明也没有被证伪。

传统上，所有的E-系数在附加的时候都等于2.5，根据反应质量，在接下来的重复中按照标准公式进行修改（参见算法SM-2到SM-5；第三章）。

反应质量是根据重复过程中的打字表现自动计算的。

两个参数被用来计算评分：

- 重复过程中的平均打字速度(SPEED)

- 条目的键入次数（COUNT），表明在重复过程中，在该重复的平均键入率达到该项目有史以来最大键入率的87%之前，该项目被键入了多少次（单次键入的最大值）

87%这个数值，以及计算打字质量所需的所有其他数值，都是通过试验和错误选择的。

COUNT参数的值不能超过50，因为在50次键入后，重复程序就会中断，与成绩无关。

下面介绍用于计算打字质量的函数：

> ```

> function speed_quality(x);

> constant x1=0.3;   y1=0;

>          x2=0.86;  y2=5;

> begin

> speed_quality :=（y2-y1）/（x2-x1）*（x-x1）+y1。

> end;

>

> function count_quality(x);

> constant x1=20;  y1=5;

>          x2=50;  y2=1;

> begin

>     count_quality := (y2-y1)/(x2-x1)*(x-x1)+y1;

> end;

>

> function quality(count, speed, max_speed);

> begin

>     quality := count_quality(count)+speed_quality(speed/max_speed);

>     quality := quality/2;

>     if quality < 0 then quality := 0;

>     if quality > 5 then quality := 5;

> end;

>

> ```

>

> 前述函数中标识符的解释：

>

> - `speed_quality` - 计算打字质量的速度部分的函数。

> - `count_quality` - 计算打字质量的计数部分的函数。

> - `count'- 在重复过程中键入项目的数量

> - `速度` - 在重复过程中记录的平均打字速度

> `max_speed` - 该项目所记录的最大打字速度（单次打入）。

>

> 注意，(x1,y1)和(x2,y2)定义了用于计算质量的SPEED和COUNT成分的线性函数。

基于SuperMemo的打字训练程序从1990年4月1日开始应用，似乎对提高我的打字技能很有帮助。然而，关于以下问题，目前还不能提供可靠的定量数据：

- 与其他标准类型训练方案相比，SuperMemo类型训练器的效果如何？

- 该计划对水平较低或较高的学习者有什么用处（质量评估参数根据我的个人要求进行了调整）。

- 应用该方案获得的典型进展曲线是什么？

这些以及其他许多相关的问题将很快被解决。尽管如此，利用目前获得的数据，我们可以尝试回答SuperMemo的间隔重复是否可以成功应用于随机学习。答案当然是肯定的，但从类型训练者数据库中E-系数的分布可以得出一个有趣的结论（见图9.1）。

原文：![基于SuperMemo 5的触摸打字应用程序的实际屏幕打印结果(来自原论文)](https://super-memory.com/english/ol/ol_files/distribution_of_ef_in_supermemo-based_touch-type_training.jpg)

图 .9.1 - E-系数在类型训练计划的SuperMemo数据库中的分布。该分布取自该过程的第55天。

在图9.1中，引人注目的是，类型训练者数据库的 E-系数表现出明显的增加趋势。这种现象在任何一个用于确定性学习的标准SuperMemo程序的数据库中还没有被观察到。只有两种可能：要么质量评估太宽松，要么重复次数太多。第一种解释必须被排除，因为在随后的两次重复中，正如我们从上述公式中得出的结论，如果后面的重复中的表现至少没有前面的表现好，那么质量就不能超过3（要达到QUALITY>3，COUNT_QUALITY必须大于1。所以COUNT变量必须低于50，因此平均速度必须大于最大速度的87%，而在前面的重复中，最大速度只能低于或等于，因为最大速度的相同百分比被用来中断重复）。此外，只有当质量大于4时，E-系数才会增加。最后的结论一定是：**随机学习中的最佳重复间隔比确定性学习中涉及的间隔密度要小，也就是说，相应的间隔要长**。

考虑到随机学习中的重复不是单一行为，这一事实是可以预期的。这意味着，在一次重复中，为所练习的技能编码所需的突触被多次刺激，我无法想象会出现其他情况。我不会过早下结论，而是把这个问题留给进一步研究。

## 9.2.基于SuperMemo方法的打鼓训练

打鼓，以及演奏其他乐器，都可以归为需要随机学习的技能。下面我将介绍SuperMemo方法在学习构成专业鼓手的选定技能方面的示范性应用。这是为了说明可以设计训练的方式，而不是为了提出有关这种方法有效性的任何结论性数据（该计划自1990年5月10日以来一直在使用）。在所有的学习问题中，选择独立的SuperMemo项目来进行适当间隔的重复过程是至关重要的。在所考虑的例子中，个别的重复性运动任务被用作SuperMemo项目，训练的目的是提高打鼓所涉及的特定子类技能的运动表现。

在间隔打鼓训练中使用的一个示范性任务

![图片取自原文](https://super-memory.com/english/ol/ol_files/exemplary_task_in_supermemo-based_drum_training.jpg)

同样的任务嵌入在一个普通的一字长条中

![图片取自原文](https://super-memory.com/english/ol/ol_files/exemplary_task_embedded_in_regular_one-note-long_bar_in_supermemo-based_drum_training.jpg)

涉及高脚鼓、小鼓和大鼓的长达6个十六分音符长度的鼓谱的1700万个组合被筛选出来，以确定任务的难度。

- 可行性限制：

  1.击打底鼓不超过两次

2.击打小鼓不超过两次

  3. 击打擦片不超过四次运行

  4. 擦片重击次数总是单数

- 强度限制：

  1.最少击打三次底鼓

  2. 最少击打两次小鼓

  3. 最少击打四次擦片

  4.至少有一次擦片重击

- 审美限制：

  1. 重击擦片总是与击打底鼓有关

  2.小鼓的击打从不伴有击打底鼓

由此产生的1307个任务被筛选出高相似度的组合，以得出最终的300个任务。

所产生的任务表的一个片断

![图片取自原文](https://super-memory.com/english/ol/ol_files/task_table_in_supermemo-based_drum_training.jpg)

不断重复，直到达到令人满意的表现水平（根据使用者的主观估计）。为了简化学习过程的管理程序，任务被分为三个难度类别。

- A级 - 相当于E-系数2.3

- B级 - 相当于E-系数1.7

- C级 - 相当于E-系数1.4

最初，所有的任务都属于A级。在重复的过程中，保留的质量是按照以下的等级表来估计的（括号内是E-系数类别的修改情况）。

- 很好或优秀（无惩罚）

- 良好（将难度类别从A改为B或从B改为C）

- 普通(将难度类别改为C)

- 不好（将难度类别改为C，并重新设置程序，即从头开始重复）。

特定任务的重复是以使用公式计算的间隔进行的：

> ```

> I(1) = 4

> I(n) = I(n-1)*EF

>

> ```

>

> where:

>

> - `I(n)` - 第n次重复后的间隔重复

> - `EF` - E-Factor等于2.3，1.7或1.4（A级，B级或C级）。

正如在触摸打字训练中所强调的那样，随机学习的重复次数可以比确定学习的密度要小。因此，上述方案似乎是过于谨慎了。这个训练已经被一个专业鼓手应用了一个多月，并得到了非常积极的评价。然而，带来肯定意见的是该方法的普遍规律性，而不是SuperMemo重复间隔本身的效果，因为在这么短的时间内，SuperMemo无法显示出其真正的力量。同样，为了获得更多的结论，有必要对训练进行更长时间的应用。

## 小结

- SuperMemo方法可以成功地应用于随机学习的过程中

- 确定性的重复间隔对随机学习来说是有效的或过于严格的，即应用SuperMemo方法可以得到比前几章讨论的更好的结果（更大的习得率）。

- 说明了SuperMemo方法在触摸打字和打鼓训练中的示范性应用